# 8-Puzzle Solver README

## General Description

This 8-Puzzle Solver is a Python application designed to solve the 8-puzzle game using various search algorithms. The 8-puzzle consists of a 3x3 grid with tiles numbered 1-8 and one blank space. The objective is to rearrange the tiles to a specific goal state. The application includes several algorithms and utility functions to facilitate the solving process.

### Algorithms Implemented
- Breadth-First Search (BFS)
- Iterative Deepening Depth-First Search (IDDFS)
- Greedy Best-First Search (GBFS)
- A* Search (AST)

### Main Functions
- `bfs`: Implements the Breadth-First Search algorithm.
- `iddfs`: Implements the Iterative Deepening Depth-First Search algorithm.
- `gbfs`: Implements the Greedy Best-First Search algorithm.
- `ast`: Implements the A* Search algorithm.
- `subNodes`: Generates possible moves from a given puzzle state.
- `move`: Executes a move in a given direction in the puzzle.
- `Heuristic`: Calculates the heuristic value for GBFS and AST.

## State Space Representation

### States
Each state is represented as a list of integers, where each integer corresponds to a tile in the 8-puzzle grid. `0` represents the blank tile.

### Transitions
Transitions between states occur through tile movements - up, down, left, or right - contingent on the position of the blank tile.

## Heuristics for GBFS and A*

For GBFS and A*, a custom heuristic is implemented. The heuristic assesses the puzzle state based on a predefined pattern database. This database maps specific tile configurations to their respective costs, aiding in the estimation of the remaining steps to reach the goal state. The heuristic is both admissible and consistent, ensuring the efficiency and accuracy of the search algorithms.

## Optimality of Algorithms

- BFS and IDDFS: These algorithms are guaranteed to find the optimal solution path.
- GBFS and AST: The optimality of these algorithms depends on the heuristic's effectiveness. In this implementation, the custom heuristic should ensure optimality, but results may vary based on specific puzzle configurations.

## Running the Software

To run the software, follow these steps:
1. Ensure Python 3.x is installed on your system.
2. Run the command: `python algorithms.py "initial_board_state"`, where `initial_board_state` is a comma-separated string representing the initial puzzle configuration.

Example:
```bash
python algorithms.py "1,2,5,3,4,0,6,7,8"
```

## Output

The application outputs the following for each algorithm:
- The number of nodes expanded.
- The solution path as a sequence of moves.
- Additional statistics like cost, search depth, maximum search depth, and running time are also available in the code but commented out.

**Note**: A screenshot of the output is not included in this README but can be generated by running the application.

## Contributing

Contributions to the project are welcome. Please feel free to fork the repository and submit pull requests with any enhancements.
