# 8-Puzzle Solver README

## General Description

This 8-Puzzle Solver is a Python application designed to solve the 8-puzzle game using various search algorithms. The 8-puzzle consists of a 3x3 grid with tiles numbered 1-8 and one blank space. The objective is to rearrange the tiles to a specific goal state. The application includes several algorithms and utility functions to facilitate the solving process.

### Algorithms Implemented
- Breadth-First Search (BFS)
- Iterative Deepening Depth-First Search (IDDFS)
- Greedy Best-First Search (GBFS)
- A* Search (AST)

### Main Functions
- `bfs`: Implements the Breadth-First Search algorithm.
- `iddfs`: Implements the Iterative Deepening Depth-First Search algorithm.
- `gbfs`: Implements the Greedy Best-First Search algorithm.
- `ast`: Implements the A* Search algorithm.
- `subNodes`: Generates possible moves from a given puzzle state.
- `move`: Executes a move in a given direction in the puzzle.
- `Heuristic`: Calculates the heuristic value for GBFS and AST.

## State Space Representation

### States
Each state is represented as a list of integers, where each integer corresponds to a tile in the 8-puzzle grid. `0` represents the blank tile.

### Transitions
Transitions between states occur through tile movements - up, down, left, or right - contingent on the position of the blank tile.

## Heuristics for GBFS and A*

For the Greedy Best-First Search (GBFS) and A* algorithms, a custom heuristic function is used to estimate the cost of the path from the current state to the goal state. This heuristic is based on a predefined pattern database, which is a lookup table that maps specific tile configurations to their respective costs.

The cost in this context represents the minimum number of moves required to transform the given tile configuration into the goal configuration. By using this pattern database, the heuristic function can quickly estimate the remaining cost to reach the goal state from the current state, which guides the search algorithms towards promising paths.

This heuristic function is both admissible and consistent. An admissible heuristic never overestimates the cost to reach the goal, which ensures that A* is optimal. A consistent heuristic, also known as a monotonic heuristic, satisfies the condition that the estimated cost from the current node to a goal node is no greater than the cost from the current node to a successor node plus the estimated cost from the successor node to the goal. This property ensures that A* is optimally efficient.

## Optimality of Algorithms

- BFS and IDDFS: The Breadth-First Search (BFS) and Iterative Deepening Depth-First Search (IDDFS) algorithms are guaranteed to find the optimal solution path, as they explore all possible paths and always choose the shortest one.
- GBFS and AST: The optimality of the Greedy Best-First Search (GBFS) and A* algorithms depends on the effectiveness of the heuristic used. In this implementation, the custom heuristic should ensure optimality, as it is both admissible and consistent. However, the actual results may vary based on specific puzzle configurations, as the heuristic's accuracy depends on how closely the pattern database matches the true costs.

## Running the Software

To run the software, follow these steps:
1. Ensure Python 3.x is installed on your system.
2. Run the command: `python algorithms.py "initial_board_state"`, where `initial_board_state` is a comma-separated string representing the initial puzzle configuration.

Example:
```bash
python algorithms.py "0,1,2,5,3,4,0,6,7,8"
```

## Output

The application outputs the following for each algorithm:
- The number of nodes expanded.
- The solution path as a sequence of moves.
- Additional statistics like cost, search depth, maximum search depth, and running time are also available in the code but commented out.

**Note**: A screenshot of the output is not included in this README but can be generated by running the application.

## Contributing

Contributions to the project are welcome. Please feel free to fork the repository and submit pull requests with any enhancements.
